<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>METAMORPHOSIS - Flower to Jellyfish</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Syncopate:wght@400;700&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            background-color: #000;
            font-family: 'Playfair Display', serif;
            color: white;
            overflow-x: hidden;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
        }

        .ui-layer {
            position: relative;
            z-index: 10;
            pointer-events: none; /* Let scroll pass through */
        }

        section {
            position: relative;
            width: 100%;
            height: 100vh; /* Full viewport height */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        h1 {
            font-size: 8vw;
            margin: 0;
            text-transform: uppercase;
            line-height: 0.9;
            mix-blend-mode: exclusion;
        }

        h2 {
            font-family: 'Syncopate', sans-serif;
            font-size: 4vw;
            color: #ff0077; /* Pink */
            text-transform: uppercase;
            mix-blend-mode: lighten;
        }

        p {
            font-family: 'Syncopate', sans-serif;
            font-size: 1rem;
            margin-top: 20px;
            letter-spacing: 2px;
            mix-blend-mode: exclusion;
        }

        .scroll-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Syncopate';
            font-size: 10px;
            opacity: 0.5;
            z-index: 20;
        }

    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div class="scroll-indicator">SCROLL TO MUTATE</div>

    <div class="ui-layer">
        <!-- Section 1: The Flower -->
        <section class="section-1">
            <h1>Born of<br><i>Nature</i></h1>
            <p>The Bloom</p>
        </section>

        <!-- Section 2: The Pink Burst -->
        <section class="section-2">
            <h2>Neon<br>Burst</h2>
            <p>The Transformation</p>
        </section>

        <!-- Section 3: The Jellyfish -->
        <section class="section-3">
            <h1>Deep<br><i>Abyss</i></h1>
            <p>The Sentinel</p>
        </section>
    </div>

    <!-- LIBRARIES -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        gsap.registerPlugin(ScrollTrigger);

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 6;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // Better colors
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- LIGHTING ---
        // We need dynamic lights for the burst effect
        const ambientLight = new THREE.AmbientLight(0x222222, 1);
        scene.add(ambientLight);

        const mainLight = new THREE.PointLight(0xffffff, 1, 100);
        mainLight.position.set(5, 5, 5);
        scene.add(mainLight);

        const pinkLight = new THREE.PointLight(0xff0077, 0, 100); // Starts off
        pinkLight.position.set(-5, 0, 2);
        scene.add(pinkLight);

        // --- THE OBJECT ---
        // We need a VERY dense sphere to manipulate vertices into tentacles/petals
        const geometry = new THREE.SphereGeometry(2, 128, 128); 
        
        const material = new THREE.MeshPhysicalMaterial({
            color: 0xaaaaaa,       // Silver base
            emissive: 0x000000,
            metalness: 0.9,
            roughness: 0.2,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            flatShading: false, // Smooth shading
        });

        const shape = new THREE.Mesh(geometry, material);
        scene.add(shape);

        // Store original positions
        const originalPositions = geometry.attributes.position.array.slice();
        const simplex = new SimplexNoise();

        // --- ANIMATION STATE VARIABLES ---
        const params = {
            bloom: 0,           // 0 = Closed Bud, 1 = Open Flower
            burst: 0,           // 0 = Normal, 1 = Exploded/Spiky
            jellyfish: 0,       // 0 = Sphere, 1 = Jellyfish Shape
            noiseSpeed: 0.003,
            colorR: 0.7,        // RGB for Silver/White
            colorG: 0.7,
            colorB: 0.7
        };

        // --- MATH UTILS ---
        // Helper to convert Cartesian (xyz) to Spherical (radius, phi, theta)
        function toSpherical(x, y, z) {
            const r = Math.sqrt(x*x + y*y + z*z);
            const phi = Math.acos( y / r ); // Angle from Y axis
            const theta = Math.atan2(z, x); // Angle around Y axis
            return { r, phi, theta };
        }

        // --- ANIMATION LOOP ---
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += params.noiseSpeed;

            // Update Material Color based on params
            material.color.setRGB(params.colorR, params.colorG, params.colorB);
            
            // Add some emissive glow during burst
            if(params.burst > 0.1) {
                material.emissive.setHex(0xff0077);
                material.emissiveIntensity = params.burst * 0.5;
            } else {
                material.emissiveIntensity = 0;
            }

            // Rotate object
            shape.rotation.y += 0.002;

            // --- VERTEX MANIPULATION ---
            const positionAttribute = geometry.attributes.position;
            const vertex = new THREE.Vector3();

            for (let i = 0; i < positionAttribute.count; i++) {
                // Get Base Position
                const ox = originalPositions[i * 3];
                const oy = originalPositions[i * 3 + 1];
                const oz = originalPositions[i * 3 + 2];

                // Convert to Spherical for easier "Petal" math
                let { r, phi, theta } = toSpherical(ox, oy, oz);

                // 1. FLOWER LOGIC
                // Create ridges using Sine waves on Theta (around the sphere)
                // "8.0" determines number of petals
                const petalFrequency = 8.0; 
                // Petals bulge out based on sine wave
                const petalShape = Math.sin(theta * petalFrequency); 
                // Combine with Bloom factor: 
                // When bloom is 0, shape is noisy ball. When bloom is 1, petals expand.
                const flowerDistortion = 1 + (petalShape * 0.3 * params.bloom);

                // 2. BURST LOGIC (Pink Section)
                // High frequency noise
                const burstNoise = simplex.noise3D(ox * 2 + time * 5, oy * 2, oz * 2);
                const burstDistortion = params.burst * (burstNoise * 0.8); // 0.8 is intensity

                // 3. JELLYFISH LOGIC
                // If Y is negative, stretch it down. If Y is positive, keep it smooth (Dome)
                let jellyY = oy;
                let jellyX = ox;
                let jellyZ = oz;
                
                if (params.jellyfish > 0) {
                    // Tentacle Noise
                    const tentacleNoise = simplex.noise3D(ox * 2, oy * 3 - time * 2, oz * 2);
                    
                    if (oy < 0.2) {
                        // Stretch bottom downwards
                        jellyY = oy * (1 + params.jellyfish * 2); 
                        // Add waving motion to tentacles
                        jellyX += (Math.sin(oy * 5 + time * 2) * 0.2 * params.jellyfish);
                        jellyZ += (Math.cos(oy * 5 + time * 2) * 0.2 * params.jellyfish);
                        // Add noise texture to tentacles
                        jellyX += tentacleNoise * 0.3 * params.jellyfish;
                        jellyZ += tentacleNoise * 0.3 * params.jellyfish;
                    } else {
                        // Flatten the top slightly for the "Bell" shape
                        jellyY = oy * (1 - params.jellyfish * 0.3);
                    }
                }

                // --- BLENDING THE STATES ---
                // We linearly interpolate (mix) between the shapes based on scroll variables

                // Start with Sphere
                let finalX = ox;
                let finalY = oy;
                let finalZ = oz;

                // Apply Flower Morph
                finalX *= flowerDistortion;
                finalY *= flowerDistortion;
                finalZ *= flowerDistortion;

                // Apply Jellyfish Morph (overrides flower)
                // We lerp (linear interpolate) from FlowerState to JellyState
                finalX = THREE.MathUtils.lerp(finalX, jellyX, params.jellyfish);
                finalY = THREE.MathUtils.lerp(finalY, jellyY, params.jellyfish);
                finalZ = THREE.MathUtils.lerp(finalZ, jellyZ, params.jellyfish);

                // Apply Burst (adds on top of everything)
                finalX += burstDistortion * ox; // Multiply by ox direction
                finalY += burstDistortion * oy;
                finalZ += burstDistortion * oz;

                positionAttribute.setXYZ(i, finalX, finalY, finalZ);
            }

            positionAttribute.needsUpdate = true;
            geometry.computeVertexNormals();
            renderer.render(scene, camera);
        }

        animate();


        // --- GSAP TIMELINES & SCROLLTRIGGERS ---

        // 1. INTRO: BLOOMING FLOWER
        const introTl = gsap.timeline();
        // Start closed (scale 0)
        introTl.from(shape.scale, { duration: 1, x: 0, y: 0, z: 0, ease: "back.out(1.7)" });
        // Bloom opens
        introTl.to(params, { duration: 3, bloom: 1, ease: "power2.inOut" }, "-=0.5");
        // Rotate while blooming
        introTl.from(shape.rotation, { duration: 3, y: Math.PI, ease: "power2.out" }, "-=3");


        // 2. SCROLL: FLOWER -> BURST (Section 1 to 2)
        gsap.timeline({
            scrollTrigger: {
                trigger: ".section-2",
                start: "top bottom",
                end: "center center",
                scrub: true
            }
        })
        .to(params, { 
            bloom: 0.5, // Close petals slightly before burst
            burst: 1,   // Activate spike/burst
            colorR: 1,  // Pink Red
            colorG: 0,  // Pink Green
            colorB: 0.47 // Pink Blue (#ff0077)
        })
        .to(pinkLight, { intensity: 5 }, "<"); // Turn on pink light


        // 3. SCROLL: BURST -> JELLYFISH (Section 2 to 3)
        gsap.timeline({
            scrollTrigger: {
                trigger: ".section-3",
                start: "top bottom", // Starts when section 3 enters
                end: "center center",
                scrub: true
            }
        })
        .to(params, {
            burst: 0,       // Stop bursting
            jellyfish: 1,   // Morph to Jellyfish
            bloom: 0,       // Remove petals
            colorR: 0.2,    // Deep Blue/Cyan color
            colorG: 0.8,
            colorB: 1,
            noiseSpeed: 0.01 // Faster wiggling for tentacles
        })
        .to(pinkLight, { intensity: 0 }, "<") // Turn off pink light
        .to(mainLight.position, { y: 10 }, "<"); // Move light up


        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
