<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MODMEDICALIS</title>
    <!-- Imports: Londrina Solid (Head) & Montserrat (Body) -->
    <link href="https://fonts.googleapis.com/css2?family=Londrina+Solid:wght@100;300;400;900&family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #f4f4f4; 
            font-family: 'Montserrat', sans-serif;
        }
        
        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh; 
            outline: none;
            opacity: 0;
            transition: opacity 1s ease-out;
        }

        /* --- INTRO LOGO --- */
        #intro-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 99;
            display: flex; align-items: center; justify-content: center;
        }

        #intro-logo {
            width: 140px;
            opacity: 0;
            transform: scale(0.9);
            filter: drop-shadow(0 0 10px rgba(204, 119, 34, 0.3));
        }

        /* --- FINAL UI --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; 
            justify-content: center;
            padding-left: 10vw; /* Left aligned text */
            z-index: 10;
        }

        .mask-box {
            overflow: hidden; 
            position: relative;
            margin-bottom: 5px;
        }

        h1.hero {
            font-family: 'Londrina Solid', cursive; /* NEW FONT */
            font-weight: 900;
            font-size: 6vw; /* Slightly larger for this font */
            color: #1a1a1a;
            margin: 0;
            line-height: 1.0;
            transform: translateY(110%);
            opacity: 1;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        p.sub {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.2rem;
            color: #cc7722; 
            letter-spacing: 3px;
            text-transform: uppercase;
            font-weight: 600;
            transform: translateY(110%);
            margin: 0;
            margin-left: 5px;
        }
    </style>
</head>
<body>

    <!-- INTRO -->
    <div id="intro-layer">
        <img src="https://i.imgur.com/YZCD8Md.png" id="intro-logo" alt="Logo">
    </div>

    <!-- UI -->
    <div id="ui-layer">
        <div class="mask-box">
            <h1 class="hero" id="hero-text">MODMEDICALIS</h1>
        </div>
        <div class="mask-box">
            <p class="sub" id="sub-text">Let the visuals speak</p>
        </div>
    </div>

    <!-- 3D ENGINE -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';

        // --- ASSETS ---
        const ASSETS = {
            front: 'https://i.imgur.com/JCDfZlU.jpeg',
            back: 'https://i.imgur.com/O5yAK7B.jpeg',
            pages: [
                'https://i.imgur.com/N97nom9.png', 
                'https://i.imgur.com/kCa9Fsw.png', 
                'https://i.imgur.com/7Rz20Sw.png', 
                'https://i.imgur.com/1662Fkj.png', 
                'https://i.imgur.com/qdJHccQ.png', 
                'https://i.imgur.com/y7GKgIJ.png', 
                'https://i.imgur.com/ho92VGT.png'
            ]
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf4f4f4); 
        scene.fog = new THREE.FogExp2(0xf4f4f4, 0.02);

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 16);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0; 
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloom.threshold = 0.85; 
        bloom.strength = 0.3; 
        bloom.radius = 0.2;
        composer.addPass(bloom);

        // --- LIGHTING ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainLight.position.set(5, 10, 5);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.radius = 4;
        scene.add(mainLight);

        const rimLight = new THREE.PointLight(0xff8822, 2.5, 15);
        rimLight.position.set(0, 3, -6);
        scene.add(rimLight);

        // Floor
        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.ShadowMaterial({ opacity: 0.05, color: 0x000000 })
        );
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -4;
        plane.receiveShadow = true;
        scene.add(plane);

        // --- LOADING & LOGO ---
        const manager = new THREE.LoadingManager();
        const texLoader = new THREE.TextureLoader(manager);
        
        const introTl = gsap.timeline({ repeat: -1, repeatDelay: 1 });
        introTl.to("#intro-logo", { opacity: 1, duration: 0.5 })
               .to("#intro-logo", { scale: 1.1, duration: 0.1, ease: "power1.out" }) 
               .to("#intro-logo", { scale: 1.0, duration: 0.1, ease: "power1.in" })
               .to("#intro-logo", { scale: 1.1, duration: 0.1, ease: "power1.out" }) 
               .to("#intro-logo", { scale: 1.0, duration: 0.5, ease: "power1.in" });

        const textures = { pages: [] };
        
        const loadTex = (url) => {
            const t = texLoader.load(url);
            t.colorSpace = THREE.SRGBColorSpace;
            t.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return t;
        };

        textures.front = loadTex(ASSETS.front);
        textures.back = loadTex(ASSETS.back);
        ASSETS.pages.forEach(url => textures.pages.push(loadTex(url)));

        manager.onLoad = () => {
            initBook();
            introTl.kill();
            gsap.to("#intro-logo", { scale: 0.1, opacity: 0, duration: 0.5, ease: "back.in(1.7)" });
            gsap.to("#intro-layer", { opacity: 0, duration: 0.8, delay: 0.4, onComplete: () => {
                document.getElementById('intro-layer').style.display = 'none';
            }});
            gsap.to("canvas", { opacity: 1, duration: 1.5, delay: 0.5 });
            runSequence();
        };

        // --- BOOK GEOMETRY ---
        const bookGroup = new THREE.Group();
        const pivotArray = [];
        let frontCoverGroup;

        const W = 3.6; 
        const H = 5.2;
        const THICKNESS = 0.015;
        const COVER_THICKNESS = 0.06;
        
        function initBook() {
            scene.add(bookGroup);
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
            const matEdge = new THREE.MeshStandardMaterial({ color: 0xeaeaea, roughness: 0.6 });
            
            // Back Cover
            const backGeo = new THREE.BoxGeometry(W, H, COVER_THICKNESS);
            backGeo.translate(W/2 + 0.1, 0, 0); 
            const backMesh = new THREE.Mesh(backGeo, [
                matEdge, matEdge, matEdge, matEdge,
                matWhite,
                new THREE.MeshStandardMaterial({ map: textures.back, roughness: 0.4 })
            ]);
            backMesh.castShadow = true;
            backMesh.receiveShadow = true;
            bookGroup.add(backMesh);

            // Pages (1 Image per page, no repetition)
            textures.pages.forEach((tex, i) => {
                const grp = new THREE.Group();
                // Z-Stacking
                const zPos = (COVER_THICKNESS/2) + ((textures.pages.length - i) * THICKNESS);
                grp.position.z = zPos;

                const pgGeo = new THREE.BoxGeometry(W, H - 0.1, THICKNESS);
                pgGeo.translate(W/2 + 0.1, 0, 0);

                const pgMat = [
                    matEdge, matEdge, matEdge, matEdge,
                    new THREE.MeshStandardMaterial({ map: tex, roughness: 0.5 }), // Front
                    matWhite // Back
                ];

                const mesh = new THREE.Mesh(pgGeo, pgMat);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                grp.add(mesh);
                bookGroup.add(grp);
                pivotArray.push(grp);
            });

            // Front Cover
            frontCoverGroup = new THREE.Group();
            frontCoverGroup.position.z = (COVER_THICKNESS/2) + (textures.pages.length * THICKNESS) + THICKNESS + 0.01;
            bookGroup.add(frontCoverGroup);

            const frontGeo = new THREE.BoxGeometry(W, H, COVER_THICKNESS);
            frontGeo.translate(W/2 + 0.1, 0, 0);
            
            const frontMesh = new THREE.Mesh(frontGeo, [
                matEdge, matEdge, matEdge, matEdge,
                new THREE.MeshStandardMaterial({ map: textures.front, roughness: 0.4 }), 
                matWhite 
            ]);
            frontMesh.castShadow = true;
            frontMesh.receiveShadow = true;
            frontCoverGroup.add(frontMesh);

            // Spiral
            const matSilver = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, metalness: 1.0, roughness: 0.1 
            });
            const spiralH = H * 0.94; 
            const spiralR = 0.12; 
            const tubeR = 0.012; 
            
            class Helix extends THREE.Curve {
                getPoint(t) {
                    const turns = 34;
                    const angle = 2 * Math.PI * t * turns;
                    const x = spiralR * Math.cos(angle);
                    const z = spiralR * Math.sin(angle);
                    const y = (t - 0.5) * spiralH;
                    return new THREE.Vector3(x, y, z);
                }
            }
            const tubeGeo = new THREE.TubeGeometry(new Helix(), 400, tubeR, 8, false);
            const spiralMesh = new THREE.Mesh(tubeGeo, matSilver);
            spiralMesh.position.set(0, 0, frontCoverGroup.position.z / 2);
            spiralMesh.castShadow = true;
            bookGroup.add(spiralMesh);

            bookGroup.position.x = -W/2;
        }

        // --- ANIMATION SEQUENCE ---
        function runSequence() {
            const tl = gsap.timeline({ defaults: { ease: "power2.inOut" }, delay: 0.5 });

            // 1. Drop
            bookGroup.position.y = 10;
            bookGroup.rotation.set(0.5, 0.5, 0);
            tl.to(bookGroup.position, { y: 0, duration: 1.5, ease: "bounce.out" })
              .to(bookGroup.rotation, { x: 0.1, y: -0.2, z: 0, duration: 1.5 }, "<");

            // 2. Spin
            tl.to(bookGroup.rotation, { y: Math.PI * 2 - 0.2, duration: 2.2 })
              .to(camera.position, { z: 12, duration: 2.2 }, "<");

            // 3. Open
            tl.to(frontCoverGroup.rotation, { y: -3.0, duration: 1.5 })
              .to(bookGroup.rotation, { y: 0.2, x: 0.1, duration: 1.5 }, "<")
              .to(camera.position, { x: 2, duration: 1.5 }, "<");

            // 4. Zoom
            tl.to(camera.position, { x: 1.5, y: 0, z: 6, duration: 1.5 });

            // 5. Flip 1
            tl.to(pivotArray[0].rotation, { y: -2.95, duration: 1.2 });

            // 6. Flip 2 & 3
            tl.to(pivotArray[1].rotation, { y: -2.9, duration: 0.8 }, "-=0.2")
              .to(pivotArray[2].rotation, { y: -2.85, duration: 0.8 }, "-=0.4");

            // 7. Aerial
            tl.to(camera.position, { x: 0, y: 7, z: 5, duration: 2.0 })
              .to(camera.rotation, { x: -0.8, duration: 2.0 }, "<");

            // 8. FINAL: Move Right & CLOSE BOOK
            tl.addLabel("closing");
            // Move book right
            tl.to(camera.position, { x: 0, y: 0, z: 14, duration: 2.5 }, "closing")
              .to(camera.rotation, { x: 0, duration: 2.5 }, "closing")
              .to(bookGroup.position, { x: 3.5, duration: 2.5 }, "closing")
              .to(bookGroup.rotation, { y: -0.3, x: 0, duration: 2.5 }, "closing");

            // CLOSING ANIMATION (Reverse flips)
            // Close pages
            pivotArray.forEach((pivot, i) => {
                 tl.to(pivot.rotation, { y: 0, duration: 1.5 + (i*0.1) }, "closing");
            });
            // Close Cover
            tl.to(frontCoverGroup.rotation, { y: 0, duration: 2.0, ease: "power3.inOut" }, "closing");

            // --- TEXT REVEAL ---
            tl.to("#hero-text", { 
                y: "0%", 
                duration: 1.2, 
                ease: "expo.out" 
            }, "-=1.0");

            tl.to("#sub-text", { 
                y: "0%", 
                duration: 1.0, 
                ease: "expo.out" 
            }, "-=0.8");
            
            tl.eventCallback("onComplete", () => {
                window.addEventListener("mousemove", onMouseMove);
            });
        }

        // --- PARALLAX ---
        let mouseX = 0, mouseY = 0;
        function onMouseMove(e) {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = performance.now() * 0.001;
            bookGroup.position.y += Math.sin(t) * 0.001; 

            if(Math.abs(mouseX) > 0) {
                // Subtle rotation on closed book
                bookGroup.rotation.y += (mouseX * 0.05 - (bookGroup.rotation.y + 0.3)) * 0.05;
                bookGroup.rotation.x += (-mouseY * 0.05 - bookGroup.rotation.x) * 0.05;
            }
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
